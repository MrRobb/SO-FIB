<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the GNU C Library.

This is
The GNU C Library Reference Manual, for version
2.26.

Copyright (C) 1993-2017 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version
1.3 or any later version published by the Free
Software Foundation; with the Invariant Sections being "Free Software
Needs Free Documentation" and "GNU Lesser General Public License",
the Front-Cover texts being "A GNU Manual", and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License".

(a) The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>The GNU C Library: Exponents and Logarithms</title>

<meta name="description" content="The GNU C Library: Exponents and Logarithms">
<meta name="keywords" content="The GNU C Library: Exponents and Logarithms">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Mathematics.html#Mathematics" rel="up" title="Mathematics">
<link href="Hyperbolic-Functions.html#Hyperbolic-Functions" rel="next" title="Hyperbolic Functions">
<link href="Inverse-Trig-Functions.html#Inverse-Trig-Functions" rel="prev" title="Inverse Trig Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="Exponents-and-Logarithms"></a>
<div class="header">
<p>
Next: <a href="Hyperbolic-Functions.html#Hyperbolic-Functions" accesskey="n" rel="next">Hyperbolic Functions</a>, Previous: <a href="Inverse-Trig-Functions.html#Inverse-Trig-Functions" accesskey="p" rel="prev">Inverse Trig Functions</a>, Up: <a href="Mathematics.html#Mathematics" accesskey="u" rel="up">Mathematics</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Exponentiation-and-Logarithms"></a>
<h3 class="section">19.4 Exponentiation and Logarithms</h3>
<a name="index-exponentiation-functions"></a>
<a name="index-power-functions"></a>
<a name="index-logarithm-functions"></a>

<dl>
<dt><a name="index-exp"></a>Function: <em>double</em> <strong>exp</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-expf"></a>Function: <em>float</em> <strong>expf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-expl"></a>Function: <em>long double</em> <strong>expl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-expfN"></a>Function: <em>_FloatN</em> <strong>expfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-expfNx"></a>Function: <em>_FloatNx</em> <strong>expfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>e</code> (the base of natural logarithms) raised
to the power <var>x</var>.
</p>
<p>If the magnitude of the result is too large to be representable,
<code>exp</code> signals overflow.
</p></dd></dl>

<dl>
<dt><a name="index-exp2"></a>Function: <em>double</em> <strong>exp2</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-exp2f"></a>Function: <em>float</em> <strong>exp2f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-exp2l"></a>Function: <em>long double</em> <strong>exp2l</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-exp2fN"></a>Function: <em>_FloatN</em> <strong>exp2fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-exp2fNx"></a>Function: <em>_FloatNx</em> <strong>exp2fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>2</code> raised to the power <var>x</var>.
Mathematically, <code>exp2 (x)</code> is the same as <code>exp (x * log (2))</code>.
</p></dd></dl>

<dl>
<dt><a name="index-exp10"></a>Function: <em>double</em> <strong>exp10</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-exp10f"></a>Function: <em>float</em> <strong>exp10f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-exp10l"></a>Function: <em>long double</em> <strong>exp10l</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-exp10fN"></a>Function: <em>_FloatN</em> <strong>exp10fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-exp10fNx"></a>Function: <em>_FloatNx</em> <strong>exp10fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dt><a name="index-pow10"></a>Function: <em>double</em> <strong>pow10</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-pow10f"></a>Function: <em>float</em> <strong>pow10f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-pow10l"></a>Function: <em>long double</em> <strong>pow10l</strong> <em>(long double <var>x</var>)</em></dt>
<dd>





<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions compute <code>10</code> raised to the power <var>x</var>.
Mathematically, <code>exp10 (x)</code> is the same as <code>exp (x * log (10))</code>.
</p>
<p>The <code>exp10</code> functions are from TS 18661-4:2015; the <code>pow10</code>
names are GNU extensions.  The name <code>exp10</code> is
preferred, since it is analogous to <code>exp</code> and <code>exp2</code>.
</p></dd></dl>


<dl>
<dt><a name="index-log"></a>Function: <em>double</em> <strong>log</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-logf"></a>Function: <em>float</em> <strong>logf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-logl"></a>Function: <em>long double</em> <strong>logl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-logfN"></a>Function: <em>_FloatN</em> <strong>logfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-logfNx"></a>Function: <em>_FloatNx</em> <strong>logfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions compute the natural logarithm of <var>x</var>.  <code>exp (log
(<var>x</var>))</code> equals <var>x</var>, exactly in mathematics and approximately in
C.
</p>
<p>If <var>x</var> is negative, <code>log</code> signals a domain error.  If <var>x</var>
is zero, it returns negative infinity; if <var>x</var> is too close to zero,
it may signal overflow.
</p></dd></dl>

<dl>
<dt><a name="index-log10"></a>Function: <em>double</em> <strong>log10</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-log10f"></a>Function: <em>float</em> <strong>log10f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-log10l"></a>Function: <em>long double</em> <strong>log10l</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-log10fN"></a>Function: <em>_FloatN</em> <strong>log10fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-log10fNx"></a>Function: <em>_FloatNx</em> <strong>log10fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base-10 logarithm of <var>x</var>.
<code>log10 (<var>x</var>)</code> equals <code>log (<var>x</var>) / log (10)</code>.
</p>
</dd></dl>

<dl>
<dt><a name="index-log2"></a>Function: <em>double</em> <strong>log2</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-log2f"></a>Function: <em>float</em> <strong>log2f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-log2l"></a>Function: <em>long double</em> <strong>log2l</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-log2fN"></a>Function: <em>_FloatN</em> <strong>log2fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-log2fNx"></a>Function: <em>_FloatNx</em> <strong>log2fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base-2 logarithm of <var>x</var>.
<code>log2 (<var>x</var>)</code> equals <code>log (<var>x</var>) / log (2)</code>.
</p></dd></dl>

<dl>
<dt><a name="index-logb"></a>Function: <em>double</em> <strong>logb</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-logbf"></a>Function: <em>float</em> <strong>logbf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-logbl"></a>Function: <em>long double</em> <strong>logbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-logbfN"></a>Function: <em>_FloatN</em> <strong>logbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-logbfNx"></a>Function: <em>_FloatNx</em> <strong>logbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions extract the exponent of <var>x</var> and return it as a
floating-point value.  If <code>FLT_RADIX</code> is two, <code>logb</code> is equal
to <code>floor (log2 (x))</code>, except it&rsquo;s probably faster.
</p>
<p>If <var>x</var> is de-normalized, <code>logb</code> returns the exponent <var>x</var>
would have if it were normalized.  If <var>x</var> is infinity (positive or
negative), <code>logb</code> returns <em>&amp;infin;</em>.  If <var>x</var> is zero,
<code>logb</code> returns <em>&amp;infin;</em>.  It does not signal.
</p></dd></dl>

<dl>
<dt><a name="index-ilogb"></a>Function: <em>int</em> <strong>ilogb</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-ilogbf"></a>Function: <em>int</em> <strong>ilogbf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-ilogbl"></a>Function: <em>int</em> <strong>ilogbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-ilogbfN"></a>Function: <em>int</em> <strong>ilogbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-ilogbfNx"></a>Function: <em>int</em> <strong>ilogbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dt><a name="index-llogb"></a>Function: <em>long int</em> <strong>llogb</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-llogbf"></a>Function: <em>long int</em> <strong>llogbf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-llogbl"></a>Function: <em>long int</em> <strong>llogbl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-llogbfN"></a>Function: <em>long int</em> <strong>llogbfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-llogbfNx"></a>Function: <em>long int</em> <strong>llogbfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>




<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions are equivalent to the corresponding <code>logb</code>
functions except that they return signed integer values.  The
<code>ilogb</code>, <code>ilogbf</code>, and <code>ilogbl</code> functions are from ISO
C99; the <code>llogb</code>, <code>llogbf</code>, <code>llogbl</code> functions are from
TS 18661-1:2014; the <code>ilogbfN</code>, <code>ilogbfNx</code>, <code>llogbfN</code>,
and <code>llogbfNx</code> functions are from TS 18661-3:2015.
</p></dd></dl>

<p>Since integers cannot represent infinity and NaN, <code>ilogb</code> instead
returns an integer that can&rsquo;t be the exponent of a normal floating-point
number.  <samp>math.h</samp> defines constants so you can check for this.
</p>
<dl>
<dt><a name="index-FP_005fILOGB0"></a>Macro: <em>int</em> <strong>FP_ILOGB0</strong></dt>
<dd>
<p><code>ilogb</code> returns this value if its argument is <code>0</code>.  The
numeric value is either <code>INT_MIN</code> or <code>-INT_MAX</code>.
</p>
<p>This macro is defined in ISO&nbsp;C99<!-- /@w -->.
</p></dd></dl>

<dl>
<dt><a name="index-FP_005fLLOGB0"></a>Macro: <em>long int</em> <strong>FP_LLOGB0</strong></dt>
<dd>
<p><code>llogb</code> returns this value if its argument is <code>0</code>.  The
numeric value is either <code>LONG_MIN</code> or <code>-LONG_MAX</code>.
</p>
<p>This macro is defined in TS 18661-1:2014.
</p></dd></dl>

<dl>
<dt><a name="index-FP_005fILOGBNAN"></a>Macro: <em>int</em> <strong>FP_ILOGBNAN</strong></dt>
<dd>
<p><code>ilogb</code> returns this value if its argument is <code>NaN</code>.  The
numeric value is either <code>INT_MIN</code> or <code>INT_MAX</code>.
</p>
<p>This macro is defined in ISO&nbsp;C99<!-- /@w -->.
</p></dd></dl>

<dl>
<dt><a name="index-FP_005fLLOGBNAN"></a>Macro: <em>long int</em> <strong>FP_LLOGBNAN</strong></dt>
<dd>
<p><code>llogb</code> returns this value if its argument is <code>NaN</code>.  The
numeric value is either <code>LONG_MIN</code> or <code>LONG_MAX</code>.
</p>
<p>This macro is defined in TS 18661-1:2014.
</p></dd></dl>

<p>These values are system specific.  They might even be the same.  The
proper way to test the result of <code>ilogb</code> is as follows:
</p>
<div class="smallexample">
<pre class="smallexample">i = ilogb (f);
if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
  {
    if (isnan (f))
      {
        /* <span class="roman">Handle NaN.</span>  */
      }
    else if (f  == 0.0)
      {
        /* <span class="roman">Handle 0.0.</span>  */
      }
    else
      {
        /* <span class="roman">Some other value with large exponent,</span>
           <span class="roman">perhaps +Inf.</span>  */
      }
  }
</pre></div>

<dl>
<dt><a name="index-pow"></a>Function: <em>double</em> <strong>pow</strong> <em>(double <var>base</var>, double <var>power</var>)</em></dt>
<dt><a name="index-powf"></a>Function: <em>float</em> <strong>powf</strong> <em>(float <var>base</var>, float <var>power</var>)</em></dt>
<dt><a name="index-powl"></a>Function: <em>long double</em> <strong>powl</strong> <em>(long double <var>base</var>, long double <var>power</var>)</em></dt>
<dt><a name="index-powfN"></a>Function: <em>_FloatN</em> <strong>powfN</strong> <em>(_Float<var>N</var> <var>base</var>, _Float<var>N</var> <var>power</var>)</em></dt>
<dt><a name="index-powfNx"></a>Function: <em>_FloatNx</em> <strong>powfNx</strong> <em>(_Float<var>N</var>x <var>base</var>, _Float<var>N</var>x <var>power</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These are general exponentiation functions, returning <var>base</var> raised
to <var>power</var>.
</p>
<p>Mathematically, <code>pow</code> would return a complex number when <var>base</var>
is negative and <var>power</var> is not an integral value.  <code>pow</code> can&rsquo;t
do that, so instead it signals a domain error. <code>pow</code> may also
underflow or overflow the destination type.
</p></dd></dl>

<a name="index-square-root-function"></a>
<dl>
<dt><a name="index-sqrt"></a>Function: <em>double</em> <strong>sqrt</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-sqrtf"></a>Function: <em>float</em> <strong>sqrtf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-sqrtl"></a>Function: <em>long double</em> <strong>sqrtl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-sqrtfN"></a>Function: <em>_FloatN</em> <strong>sqrtfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-sqrtfNx"></a>Function: <em>_FloatNx</em> <strong>sqrtfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the nonnegative square root of <var>x</var>.
</p>
<p>If <var>x</var> is negative, <code>sqrt</code> signals a domain error.
Mathematically, it should return a complex number.
</p></dd></dl>

<a name="index-cube-root-function"></a>
<dl>
<dt><a name="index-cbrt"></a>Function: <em>double</em> <strong>cbrt</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-cbrtf"></a>Function: <em>float</em> <strong>cbrtf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-cbrtl"></a>Function: <em>long double</em> <strong>cbrtl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-cbrtfN"></a>Function: <em>_FloatN</em> <strong>cbrtfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-cbrtfNx"></a>Function: <em>_FloatNx</em> <strong>cbrtfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the cube root of <var>x</var>.  They cannot
fail; every representable real value has a representable real cube root.
</p></dd></dl>

<dl>
<dt><a name="index-hypot"></a>Function: <em>double</em> <strong>hypot</strong> <em>(double <var>x</var>, double <var>y</var>)</em></dt>
<dt><a name="index-hypotf"></a>Function: <em>float</em> <strong>hypotf</strong> <em>(float <var>x</var>, float <var>y</var>)</em></dt>
<dt><a name="index-hypotl"></a>Function: <em>long double</em> <strong>hypotl</strong> <em>(long double <var>x</var>, long double <var>y</var>)</em></dt>
<dt><a name="index-hypotfN"></a>Function: <em>_FloatN</em> <strong>hypotfN</strong> <em>(_Float<var>N</var> <var>x</var>, _Float<var>N</var> <var>y</var>)</em></dt>
<dt><a name="index-hypotfNx"></a>Function: <em>_FloatNx</em> <strong>hypotfNx</strong> <em>(_Float<var>N</var>x <var>x</var>, _Float<var>N</var>x <var>y</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return <code>sqrt (<var>x</var>*<var>x</var> +
<var>y</var>*<var>y</var>)</code>.  This is the length of the hypotenuse of a right
triangle with sides of length <var>x</var> and <var>y</var>, or the distance
of the point (<var>x</var>, <var>y</var>) from the origin.  Using this function
instead of the direct formula is wise, since the error is
much smaller.  See also the function <code>cabs</code> in <a href="Absolute-Value.html#Absolute-Value">Absolute Value</a>.
</p></dd></dl>

<dl>
<dt><a name="index-expm1"></a>Function: <em>double</em> <strong>expm1</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-expm1f"></a>Function: <em>float</em> <strong>expm1f</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-expm1l"></a>Function: <em>long double</em> <strong>expm1l</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-expm1fN"></a>Function: <em>_FloatN</em> <strong>expm1fN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-expm1fNx"></a>Function: <em>_FloatNx</em> <strong>expm1fNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return a value equivalent to <code>exp (<var>x</var>) - 1</code>.
They are computed in a way that is accurate even if <var>x</var> is
near zero&mdash;a case where <code>exp (<var>x</var>) - 1</code> would be inaccurate owing
to subtraction of two numbers that are nearly equal.
</p></dd></dl>

<dl>
<dt><a name="index-log1p"></a>Function: <em>double</em> <strong>log1p</strong> <em>(double <var>x</var>)</em></dt>
<dt><a name="index-log1pf"></a>Function: <em>float</em> <strong>log1pf</strong> <em>(float <var>x</var>)</em></dt>
<dt><a name="index-log1pl"></a>Function: <em>long double</em> <strong>log1pl</strong> <em>(long double <var>x</var>)</em></dt>
<dt><a name="index-log1pfN"></a>Function: <em>_FloatN</em> <strong>log1pfN</strong> <em>(_Float<var>N</var> <var>x</var>)</em></dt>
<dt><a name="index-log1pfNx"></a>Function: <em>_FloatNx</em> <strong>log1pfNx</strong> <em>(_Float<var>N</var>x <var>x</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return a value equivalent to <code>log&nbsp;(1&nbsp;+&nbsp;<var>x</var>)</code><!-- /@w -->.
They are computed in a way that is accurate even if <var>x</var> is
near zero.
</p></dd></dl>

<a name="index-complex-exponentiation-functions"></a>
<a name="index-complex-logarithm-functions"></a>

<p>ISO&nbsp;C99<!-- /@w --> defines complex variants of some of the exponentiation and
logarithm functions.
</p>
<dl>
<dt><a name="index-cexp"></a>Function: <em>complex double</em> <strong>cexp</strong> <em>(complex double <var>z</var>)</em></dt>
<dt><a name="index-cexpf"></a>Function: <em>complex float</em> <strong>cexpf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt><a name="index-cexpl"></a>Function: <em>complex long double</em> <strong>cexpl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt><a name="index-cexpfN"></a>Function: <em>complex _FloatN</em> <strong>cexpfN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt><a name="index-cexpfNx"></a>Function: <em>complex _FloatNx</em> <strong>cexpfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return <code>e</code> (the base of natural
logarithms) raised to the power of <var>z</var>.
Mathematically, this corresponds to the value
</p>
<p><em>exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))</em>
</p></dd></dl>

<dl>
<dt><a name="index-clog"></a>Function: <em>complex double</em> <strong>clog</strong> <em>(complex double <var>z</var>)</em></dt>
<dt><a name="index-clogf"></a>Function: <em>complex float</em> <strong>clogf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt><a name="index-clogl"></a>Function: <em>complex long double</em> <strong>clogl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt><a name="index-clogfN"></a>Function: <em>complex _FloatN</em> <strong>clogfN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt><a name="index-clogfNx"></a>Function: <em>complex _FloatNx</em> <strong>clogfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the natural logarithm of <var>z</var>.
Mathematically, this corresponds to the value
</p>
<p><em>log (z) = log (cabs (z)) + I * carg (z)</em>
</p>
<p><code>clog</code> has a pole at 0, and will signal overflow if <var>z</var> equals
or is very close to 0.  It is well-defined for all other values of
<var>z</var>.
</p></dd></dl>


<dl>
<dt><a name="index-clog10"></a>Function: <em>complex double</em> <strong>clog10</strong> <em>(complex double <var>z</var>)</em></dt>
<dt><a name="index-clog10f"></a>Function: <em>complex float</em> <strong>clog10f</strong> <em>(complex float <var>z</var>)</em></dt>
<dt><a name="index-clog10l"></a>Function: <em>complex long double</em> <strong>clog10l</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt><a name="index-clog10fN"></a>Function: <em>complex _FloatN</em> <strong>clog10fN</strong> <em>(complex _Float<var>N</var> <var>z</var>)</em></dt>
<dt><a name="index-clog10fNx"></a>Function: <em>complex _FloatNx</em> <strong>clog10fNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>
<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the base 10 logarithm of the complex value
<var>z</var>.  Mathematically, this corresponds to the value
</p>
<p><em>log10 (z) = log10 (cabs (z)) + I * carg (z) / log (10)</em>
</p>
<p>All these functions, including the <code>_Float<var>N</var></code> and
<code>_Float<var>N</var>x</code> variants, are GNU extensions.
</p></dd></dl>

<dl>
<dt><a name="index-csqrt"></a>Function: <em>complex double</em> <strong>csqrt</strong> <em>(complex double <var>z</var>)</em></dt>
<dt><a name="index-csqrtf"></a>Function: <em>complex float</em> <strong>csqrtf</strong> <em>(complex float <var>z</var>)</em></dt>
<dt><a name="index-csqrtl"></a>Function: <em>complex long double</em> <strong>csqrtl</strong> <em>(complex long double <var>z</var>)</em></dt>
<dt><a name="index-csqrtfN"></a>Function: <em>complex _FloatN</em> <strong>csqrtfN</strong> <em>(_Float<var>N</var> <var>z</var>)</em></dt>
<dt><a name="index-csqrtfNx"></a>Function: <em>complex _FloatNx</em> <strong>csqrtfNx</strong> <em>(complex _Float<var>N</var>x <var>z</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return the complex square root of the argument <var>z</var>.  Unlike
the real-valued functions, they are defined for all values of <var>z</var>.
</p></dd></dl>

<dl>
<dt><a name="index-cpow"></a>Function: <em>complex double</em> <strong>cpow</strong> <em>(complex double <var>base</var>, complex double <var>power</var>)</em></dt>
<dt><a name="index-cpowf"></a>Function: <em>complex float</em> <strong>cpowf</strong> <em>(complex float <var>base</var>, complex float <var>power</var>)</em></dt>
<dt><a name="index-cpowl"></a>Function: <em>complex long double</em> <strong>cpowl</strong> <em>(complex long double <var>base</var>, complex long double <var>power</var>)</em></dt>
<dt><a name="index-cpowfN"></a>Function: <em>complex _FloatN</em> <strong>cpowfN</strong> <em>(complex _Float<var>N</var> <var>base</var>, complex _Float<var>N</var> <var>power</var>)</em></dt>
<dt><a name="index-cpowfNx"></a>Function: <em>complex _FloatNx</em> <strong>cpowfNx</strong> <em>(complex _Float<var>N</var>x <var>base</var>, complex _Float<var>N</var>x <var>power</var>)</em></dt>
<dd>


<p>Preliminary:
| MT-Safe 
| AS-Safe 
| AC-Safe 
| See <a href="POSIX-Safety-Concepts.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</p>

<p>These functions return <var>base</var> raised to the power of
<var>power</var>.  This is equivalent to <code>cexp&nbsp;(y&nbsp;*&nbsp;clog&nbsp;(x))</code><!-- /@w -->
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Hyperbolic-Functions.html#Hyperbolic-Functions" accesskey="n" rel="next">Hyperbolic Functions</a>, Previous: <a href="Inverse-Trig-Functions.html#Inverse-Trig-Functions" accesskey="p" rel="prev">Inverse Trig Functions</a>, Up: <a href="Mathematics.html#Mathematics" accesskey="u" rel="up">Mathematics</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
